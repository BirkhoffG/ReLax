# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/01_data.scm.ipynb.

# %% ../../nbs/01_data.scm.ipynb 2
from __future__ import annotations
from ..import_essentials import *
import scipy
from causalgraphicalmodels import CausalGraphicalModel, StructuralCausalModel

try: 
    import causalgraphicalmodels
except: 
    raise ModuleNotFoundError("`causalgraphicalmodels` is not installed. "
        "Try to install via `pip install git+https://github.com/BirkhoffG/causalgraphicalmodels.git`.")

# %% auto 0
__all__ = ['BaseDistribution', 'Normal', 'MixtureOfGaussians', 'sanity_3_lin', 'CausalModel']

# %% ../../nbs/01_data.scm.ipynb 4
class BaseDistribution(ABC):
    def __init__(self, name: str):
        self.name = name

    @abstractmethod
    def sample(self, size: int):
        pass

    @abstractmethod
    def pdf(self, value):
        pass

# %% ../../nbs/01_data.scm.ipynb 5
class Normal(BaseDistribution):
  def __init__(self, mean: int | float, var: int | float):
    super().__init__(f'Normal (mean={mean}, var={var})')
    self.mean = mean
    self.var = var

  def sample(self, size=1):
    tmp = [np.random.normal(self.mean, np.sqrt(self.var)) for _ in range(size)]
    return tmp[0] if size == 1 else tmp

  def pdf(self, value):
    return scipy.stats.norm(self.mean, self.var).pdf(value)


class MixtureOfGaussians(BaseDistribution):
  def __init__(self, probs, means, vars):
    if np.sum(probs) == 1.:
      raise ValueError('Mixture probabilities must sum to 1.')
    if len(probs) == len(means) == len(vars):
      raise ValueError('Length mismatch.')
    
    self.probs = probs
    self.means = means
    self.vars = vars
    super().__init__(f'MixtureOfGaussians (mean={probs}, means={means}, vars={vars}')

  def sample(self, size=1):
    tmp = [
      np.random.normal(self.means[mixture_idx], np.sqrt(self.vars[mixture_idx]))
      for mixture_idx in np.random.choice(len(self.probs), size=size, p=self.probs)
    ]
    return tmp[0] if size == 1 else tmp

  def pdf(self, value):
    return np.sum([
      prob * scipy.stats.norm(mean, var).pdf(value)
      for (prob, mean, var) in zip(self.probs, self.means, self.vars)
    ])

# %% ../../nbs/01_data.scm.ipynb 7
def sanity_3_lin():
    structural_equations = {
        "x1": lambda n_samples: n_samples,
        "x2": lambda n_samples, x1: -x1 + n_samples,
        "x3": lambda n_samples, x1, x2: 0.5 * (0.1 * x1 + 0.5 * x2) + n_samples,
    }
    noises_distributions = {
        "u1": MixtureOfGaussians([0.5, 0.5], [-2, +1], [1.5, 1]),
        "u2": Normal(0, 1),
        "u3": Normal(0, 1),
    }
    continuous = list(structural_equations.keys()) + list(
        noises_distributions.keys()
    )
    categorical = []
    immutables = []

    return (
        structural_equations,
        noises_distributions,
        continuous,
        categorical,
        immutables,
    )

# %% ../../nbs/01_data.scm.ipynb 8
def _load_scm_equations(
    scm_class: str # Name of the structural causal model.
) -> Tuple[
    Dict[str, Callable], 
    Dict[str, Callable], 
    list, list, list]: # return scm equations
    
    scm_func_dict = {
        'sanity_3_lin': sanity_3_lin
    }
    if not scm_class in scm_func_dict:
        raise ValueError(f'{scm_class} should be one of {scm_func_dict.keys()}')
    return scm_func_dict[scm_class]()

# %% ../../nbs/01_data.scm.ipynb 10
class CausalModel:
    def __init__(
        self,
        scm_class: str # Name of the structural causal model.
    ):
        (
            self._structural_equations,
            self._noise_distributions,
            self._continuous,
            self._categorical,
            self._immutables,
        ) = self.load_scm_equations(scm_class)
        self.scm = StructuralCausalModel(self._structural_equations)
        self._cgm = self._scm.cgm

        self._endogenous = list(self._structural_equations_np.keys())
        self._exogenous = list(self._noise_distributions.keys())

        self._continuous_noise = list(set(self._continuous) - set(self.endogenous))
        self._categorical_noise = list(set(self._categorical) - set(self.endogenous))

        self._continuous = list(set(self._continuous) - set(self._exogenous))
        self._categorical = list(set(self._categorical) - set(self._exogenous))

    @staticmethod
    def load_scm_equations(
        scm_class: str # Name of the structural causal model.
    ) -> Tuple[
        Dict[str, Callable], 
        Dict[str, Callable], 
        list, list, list]: # return scm equations
        """Load structural causal equations."""
        
        return _load_scm_equations(scm_class)
